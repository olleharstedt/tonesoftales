-- MySQL dump 10.13  Distrib 5.5.34, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: d37433
-- ------------------------------------------------------
-- Server version	5.5.34-0ubuntu0.12.10.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `ds_game`
--
-- WHERE:  id=37

LOCK TABLES `ds_game` WRITE;
/*!40000 ALTER TABLE `ds_game` DISABLE KEYS */;
INSERT INTO `ds_game` VALUES (37,'Backgammon','','function init()\n\n  -- Arrows\n  local redup = deck1.cards[1]\n  redup.facing = \"up\"\n  local reddown = deck1.cards[2]\n  reddown.facing = \"up\"\n  local blackup = deck1.cards[3]\n  blackup.facing = \"up\"\n  local blackdown = deck1.cards[4]\n  blackdown.facing = \"up\"  \n  \n  -- Black and white markers\n  whites = {}\n  blacks = {}\n  for i = 5, 19 do\n    deck1.cards[i].facing = \"up\"\n    table.insert(whites, deck1.cards[i])\n  end\n  for i = 20, 34 do\n    deck1.cards[i].facing = \"up\"\n    table.insert(blacks, deck1.cards[i])\n  end\n  \n  -- Copy 15 white markers\n  --[[\n  for i = 1, 15 do\n  	local white = shallowcopy(deck1.cards[5])\n    white.position = {top = 0, left = 0, rotation = 0}\n    table.insert(whites,white)\n  end\n  \n  -- Copy 15 black markers\n  for i = 1, 15 do\n    local black = shallowcopy(deck1.cards[6])\n    black.position = {top = 0, left = 0, rotation = 0}\n    table.insert(blacks, black)\n  end\n  --]]\n  \n\n    \n  -- Stars in the middle\n  local stars = deck1.cards[35]\n  stars.facing = \"up\"\n  \n  -- Table formating\n  table_slots.rows = 2\n  table_slots.cols = 13\n  table_slots.width = 50\n  table_slots.height = 200\n  table_slots.title = \"Backgammon\"\n  \n  for i = 1, 24 do\n    table_slots[i] = {__type = \"stack\"}\n  end\n  \n  -- Put red down arrows\n  for i = 1, 11, 2 do\n    table.insert(table_slots[i], reddown)\n  end\n  \n  -- Put black down arrows\n  for i = 2, 12, 2 do\n    table.insert(table_slots[i], blackdown)\n  end\n  \n  -- Put red up arrows\n  for i = 14, 24, 2 do\n    table.insert(table_slots[i], redup)\n  end\n  \n  -- Put black up arrows\n  for i = 13, 23, 2 do\n    table.insert(table_slots[i], blackup)\n  end\n  \n  -- Put stars in middle\n  local stack = {__type = \"stack\"}\n  table.insert(stack, stars)\n  table.insert(table_slots, 7, stack)\n  local stack = {__type = \"stack\"}\n  table.insert(stack, stars)\n  table.insert(table_slots, 20, stack)\n  \n  log(dump(table_slots))\n  \n  -- Set prison slots, where taken pieces will go\n  player1.prison = 7\n  if (player2) then player2.prison = 20 end\n  \n  -- Board setup, whites\n  local j = 0\n  for i = 5, 9 do\n    deck1.cards[i].position.top = j * 35\n    j = j + 1\n    table.insert(table_slots[1], deck1.cards[i])\n  end\n  j = 0\n  for i = 10, 11 do\n    deck1.cards[i].position.top = j * 35\n    j = j + 1\n    table.insert(table_slots[13], deck1.cards[i])\n  end\n  j = 0\n  for i = 12, 14 do\n    deck1.cards[i].position.top = 200 - (j * 35) - 35\n    table.insert(table_slots[18], deck1.cards[i])\n    j = j + 1\n  end\n  j = 0\n  for i = 15, 19 do\n    deck1.cards[i].position.top = 200 - (j * 35) - 35\n    table.insert(table_slots[21], deck1.cards[i])\n    j = j + 1\n  end\n  \n  -- Board setup, blacks\n  j = 0\n  for i = 20, 22 do\n    deck1.cards[i].position.top = j * 35\n    table.insert(table_slots[5], deck1.cards[i])\n    j = j + 1\n  end\n  j = 0\n  for i = 23, 27 do\n    deck1.cards[i].position.top = j * 35\n    table.insert(table_slots[8], deck1.cards[i])\n    j = j + 1\n  end\n  j = 0\n  for i = 28, 32 do\n    deck1.cards[i].position.top = 200 - (j * 35) - 35\n    table.insert(table_slots[14], deck1.cards[i])\n    j = j + 1\n  end\n  j = 0\n  for i = 33, 34 do\n    deck1.cards[i].position.top = 200 - (j * 35) - 35\n    table.insert(table_slots[26], deck1.cards[i])\n    j = j + 1\n  end\n  \n  update_table()\n  \n  chat(player1.name .. \" play as white\")\n  if (player2) then chat(player2.name .. \" play as black\") end\n  \n  -- Add resign button\n  for _, p in ipairs(players) do\n    add_gadget {\n      gadget_id = p.player_nr,\n      type = \"button\",\n      text = \"Resign\",\n      players = {p},\n      callback = function(player)\n        chat(player.name .. \" gave up\")\n        game_over()\n      end\n    }\n  end\n  \n  -- Set home slots\n  player1.home = {21, 22, 23, 24, 25, 26}\n  if player2 then player2.home = {8, 9, 10, 11, 12, 13} end\n  \n  -- Function to calculate distance to bear off\n  player1.home_distance = function(slot_nr) return -(slot_nr - 27) end\n  if player2 then player2.home_distance = function(slot_nr) return -(slot_nr - 14) end end\n  \n  player1.mark_title = \"backg red\"\n  if player2 then player2.mark_title = \"backg black\" end\n  \n  -- The road to walk, in slot_nrs\n  player1.road = {13, 12, 11, 10, 9, 8, 6, 5, 4, 3, 2, 1, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26}\n  if player2 then player2.road = {26, 25, 24, 23, 22, 21, 19, 18, 17, 16, 15, 14, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13} end\n    \n  -- Set marks\n  player1.marks = whites\n  if player2 then player2.marks = blacks end\n  \nend\n  \n-- Fix slot so marks lie nicely on table\n-- slot should have type \"stack\"\nfunction format_slot(slot, slot_nr)\n  \n  for i = 2, #slot do\n    if slot_nr >= 1 and slot_nr <= 13 then\n      -- Down-pointing arrows\n      local top = 35 * i - 70\n      if (i - 1) / 5 > 1 then\n        top = top - 160\n      end\n      slot[i].position.top = top\n    elseif slot_nr >= 14 and slot_nr <= 26 then\n      -- Up-pointing arrows\n      local top = 235 - (i * 35)\n      if (i - 1) / 5 > 1 then\n        top = top + 160\n      end\n      slot[i].position.top =  top\n      log(\"up-pointing arrow, top = \" .. slot[i].position.top)\n    end\n  end\n  \nend\n  \n-- Format pieces at prison (middle stars)\nfunction format_prison(player)\n  \n  if player.player_nr == 1 then\n    -- White prison at top\n    for i = 2, #table_slots[player.prison] do\n      local top = 20 * i\n      table_slots[player.prison][i].position.top = top\n    end\n  else\n    -- Black prison at bottom\n    for i = 2, #table_slots[player.prison] do\n      local top = 160 - (i * 20)\n      table_slots[player.prison][i].position.top = top\n    end\n  end\n  \nend\n\n-- Enable draggable for player p\n-- Run at onbeginturn\n-- Assumes p1 play as white, p2 as black\nfunction draggable(p)\n  \n  slot_nrs = {}\n  \n  local opponent_color = p.player_nr == 1 and \"black\" or \"white\"\n\n   \n  -- Do not enable slots where there is 2 or more opponent pieces    \n  for i = 1, 26 do\n    if i == 7 or i == 20 then\n      -- Middle stars of board, don\'t add\n    else\n      if table_slots[i].__type == \"stack\" and count(table_slots[i], opponent_color) > 1 then\n        -- Skip this one\n      else\n        table.insert(slot_nrs, i)\n      end\n    end\n  end\n\n  \n  return slot_nrs\n  \nend\n\n-- The distance in int, amount of steps to reach dest from src\n-- White should move in a positive distance, black in a negative\nfunction distance(src, dest)\n  -- The way the white player moves\n  local white_road = {\n    13, 12, 11, 10, 9, 8, 6, 5, 4, 3, 2, 1, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26\n  }\n  \n  local start = nil\n  \n  for k, v in ipairs(white_road) do\n    if v == src.slot_nr then\n      start = k\n    end\n  end\n  \n  local end_ = nil\n  \n  for k, v in ipairs(white_road) do\n    if v == dest.slot_nr then\n      end_ = k\n    end\n  end\n  \n  assert(start and end_, \"distance: Did not find start or end_\")\n  \n  return end_ - start\n  \nend\n\n-- Count pieces in a table slot\n-- Optional color = \"white\"|\"black\"\nfunction count(slot, color) \n  if color then\n    if color == \"black\" then\n      if slot.__type == \"stack\" and #slot > 1 and slot[2].title == \"backg black\" then\n        return #slot - 1\n      end\n    elseif color == \"white\" then\n      if slot.__type == \"stack\" and #slot > 1 and slot[2].title == \"backg red\" then\n        return #slot - 1\n      end\n    else\n      error(\"Wrong color: \" .. color)\n  end\n  else\n    if slot.__type == \"stack\" and #slot > 1 then\n      return #slot - 1 -- Don\'t count background element\n    end\n  end\n\n  return 0\n\nend\n\n-- True if it\'s @p turn\nfunction my_turn(p)\n  return players_turn.player_nr == p.player_nr\nend\n\n-- Check if player @p has won\n-- A player win when he/she has no marks left on the board\nfunction check_game_over(p)\n  \n  local marks_left = false\n  \n  for i = 1, 26 do\n    local slot = table_slots[i]\n    if #slot > 1 and slot[2].title == p.mark_title then\n      marks_left = true\n    end\n  end\n  \n  if not marks_left then\n    chat(p.name .. \" won!\")\n    --game_over()\n    return true\n  end\n  \n  return false\n  \nend\n\n-- Enables all marks. Only run if prison is empty\nfunction enable_all_draggable(player, slot_list)\n  local marks = player.player_nr == 1 and whites or blacks\n  \n  enable_draggable({player}, marks, slot_list, function(player, src, dest)\n      if my_turn(player) then\n        \n        local dist = distance(src, dest)\n        \n        -- Abort if piece is dropped on same slice\n        if dist == 0 then\n          return\n        end\n        \n        -- chat(player.name .. \" dropped something from \" .. src.slot_nr .. \" to \" .. dest.slot_nr)\n        \n        log(\"distance = \" .. tostring(distance(src, dest)))\n        \n        local opponent_title = player.player_nr == 1 and \"backg black\" or \"backg red\"\n        local opponent = player.player_nr == 1 and player2 or player1\n        \n        for k, v in pairs(player.moves) do\n          if player.player_nr == 2 then v = -v end -- Revert if black player\n          if v == dist then\n            --table.remove(player.moves, k)\n            player.moves[k] = nil\n            \n            --move_card(table_slots[src.slot_nr][src.index], dest, function() end)\n            --sleep(500)\n            \n            -- Check if there was exactly one opponent piece on the slot\n            if (table_slots[dest.slot_nr][2] and\n                table_slots[dest.slot_nr][2].title == opponent_title) then\n              chat(player.name .. \" grabbed a piece!\")\n              opponent.taken = true\n              local mark = table.remove(table_slots[dest.slot_nr], 2)\n              table.insert(table_slots[opponent.prison], mark)              \n              format_prison(opponent)\n              local mark = table.remove(table_slots[src.slot_nr], #table_slots[src.slot_nr])\n              table.insert(table_slots[dest.slot_nr], mark)\n              format_slot(table_slots[dest.slot_nr], dest.slot_nr)\n              format_slot(table_slots[src.slot_nr], src.slot_nr)\n              break\n            else\n              local mark = table.remove(table_slots[src.slot_nr], #table_slots[src.slot_nr])\n              table.insert(table_slots[dest.slot_nr], mark)\n              -- Fix mark top px distance\n              format_slot(table_slots[dest.slot_nr], dest.slot_nr)\n              format_slot(table_slots[src.slot_nr], src.slot_nr)\n              break\n            end\n          end\n        end\n        \n        update_table()\n        \n        if #player.moves == 0 then\n          end_turn()\n          return\n        end\n              \n        -- If all marks are in home, enable onclick\n        if not mark_outside_home(player) then\n          log(\"enable bearoff in draggable\")\n          enable_bearoff(player)\n        else\n          log(\"mark outside home in draggable\")\n        end\n        \n        -- Check if the player can move\n        if not can_move(player) then\n          chat(\"No legal moves left for \" .. player.name .. \", ending turn\")\n          end_turn()\n          return\n        end\n        \n      end\n    end\n  )\n  \nend\n\nfunction enable_bearoff(player)\n\n  -- Enable clickable to get mark out of the board\n  local marks = player.player_nr == 1 and whites or blacks\n  \n  enable_onclick(marks, function(player, card)\n      \n      log(\"onclick\")\n      \n      local location = __locate_card(card)\n      \n      --log(dump(location))\n      \n      if my_turn(player) then\n        for k, move in pairs(player.moves) do\n          -- Get distance to bear off\n          local distance = player.home_distance(location.slot_nr)\n          log(\"distance = \" .. distance)\n          if move == distance then\n            log(\"move == distance\")\n            table.remove(table_slots[location.slot_nr], location.index)\n            table.remove(player.moves, k)\n            update_table()\n          end\n          \n          -- Can also bear off mark if dice is higher\n          if move > distance then\n            log(\"move > distance \" .. move .. \" \" .. distance)\n            \n            -- Check so this marker is the highest available for this move\n            local highest_move = 0\n            for k2, home_slot_nr in ipairs(player.home) do\n              if #table_slots[home_slot_nr] > 1 and\n                table_slots[home_slot_nr][2].title == player.mark_title and\n                player.home_distance(home_slot_nr) <= move then\n                \n                -- home_slot_nr < move then\n                log(\"home slot \" .. home_slot_nr)\n                \n                local dist = player.home_distance(home_slot_nr)\n                \n                if dist > highest_move then highest_move = dist end\n              end\n            end\n            \n            log(\"highest_move = \" .. highest_move)\n            \n            if highest_move == player.home_distance(location.slot_nr) then\n              \n              table.remove(table_slots[location.slot_nr], location.index)\n              table.remove(player.moves, k)\n              update_table()\n            else\n              --chat(\"Play another checker\")\n            end\n            \n          end\n          \n        end\n      end\n      \n      if check_game_over(player) then\n        game_over()\n        return\n      end\n      \n      if #player.moves == 0 then\n        end_turn()\n        return\n      end\n      \n    end\n  )\nend\n\n-- True if @player has a mark outside it\'s home\nfunction mark_outside_home(player)\n  \n  log(\"mark_outside_home()\")\n\n  if (player.player_nr == 1) then\n    -- Road excluding home\n    local white_ex_home = {1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}\n    for _, nr in ipairs(white_ex_home) do\n      local slot = table_slots[nr]\n      for i = 2, #slot do\n        if slot[2].title == \"backg red\" then \n          log(\"mark outside home in slot nr \" .. nr)\n          log(dump(slot))\n          return true \n        end\n      end\n    end\n  else\n    local black_ex_home = {1, 2, 3, 4, 5, 6, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26}\n    for _, nr in ipairs(black_ex_home) do\n      local slot = table_slots[nr]\n      for i = 2, #slot do\n        if slot[2].title == \"backg black\" then \n          log(\"mark outside home in slot nr \" .. nr)\n          return true \n        end\n      end\n    end\n  end\n  \n  log(\"no mark outside home\")\n  return false\n  \nend\n\n-- True if the player can make a move\nfunction can_move(p)\n  \n  log(\"can_move()\")\n\n  local mark_outside_home_ = mark_outside_home(p)\n  local prison_slot = table_slots[p.prison]\n  \n  -- For all moves\n  for _, move in pairs(p.moves) do\n    -- For all marks\n    for _, mark in ipairs(p.marks) do\n      \n      local status, location = pcall(function() return __locate_card(mark) end)\n      if status then\n        local slot_nr = location.slot_nr\n        \n        -- Check prison\n        if #prison_slot > 1 then\n          for i = 1, 6 do\n            if i == move then\n              local slot_nr = p.road[i]\n              local slot = table_slots[slot_nr]\n              if #slot > 1 and slot[2].title == p.mark_title then\n                log(\"can enter my slot nr \" .. slot_nr)\n                return true\n              end\n              if #slot == 1 then\n                log(\"can enter empty slot nr \" .. slot_nr)\n                return true\n              end\n            end\n          end\n          \n          -- Cannot enter piece, abort\n          return false\n          \n        end\n        \n        -- Loop the road\n        for k, v in ipairs(p.road) do\n          if v == slot_nr then\n            local next_slot_nr = p.road[k + move]\n            \n            log(\"next_slot_nr = \" .. tostring(next_slot_nr))\n            \n            if next_slot_nr then\n              local next_slot = table_slots[next_slot_nr]\n              \n              log(\"#next_slot = \" .. #next_slot)\n              \n              if next_slot and next_slot[2] then\n                if next_slot[2].title == p.mark_title then\n                  -- Next move slot is ours, we can move\n                  log(\"next slot is our slot\")\n                  return true\n                end\n                \n                if #next_slot == 2 then\n                  -- Exactly one piece to pick\n                  log(\"next slot has exactly 1 piece\")\n                  return true\n                end\n                \n              elseif next_slot and #next_slot == 1 then\n                -- Next move slot is empty, we can move here!\n                log(\"next slot is empty, slot_nr = \" .. next_slot_nr)\n                return true\n              end\n              \n            end\n          end\n        end\n        \n        -- Check if we can bear off\n        if not mark_outside_home_ then\n          if p.player_nr == 1 then\n            for i = 21, 26 do\n              local slot = table_slots[i]\n              if #slot > 1 and slot[2].title == p.mark_title then\n                log(\"i = \" .. i)\n                log(\"move = \" .. move)\n                log(\"home distance = \" .. p.home_distance(i))\n                if move >= p.home_distance(i) then\n                  log(\"can bear off\")\n                  return true\n                end\n              end\n            end\n          end\n          \n          if p.player_nr == 2 then\n            for i = 8, 13 do\n              local slot = table_slots[i]\n              if #slot > 1 and slot[2].title == p.mark_title then\n                if move >= p.home_distance(i) then\n                  log(\"can bear off\")\n                  return true\n                end\n              end\n            end\n          end\n          \n        end\n\n        \n      end -- end status for locate card\n      \n    end -- end loop marks\n    \n  end -- end loop moves\n  \n  return false\n  \nend\n\n-- A shallow copy function for tables\nfunction shallowcopy(orig)\n  local orig_type = type(orig)\n  local copy\n  if orig_type == \'table\' then\n    copy = {}\n    for orig_key, orig_value in pairs(orig) do\n      copy[orig_key] = orig_value\n    end\n  else -- number, string, boolean, etc\n    copy = orig\n  end\n  return copy\nend',22,1,2,1,1,2,1,1,'function onpickup_all(player, deck)\nend','function onplay_all(player, card)\nend','function onendturn(player)\n  \n  -- Remove dice\n  player.slots[1] = nil\n  player.slots[2] = nil\n  \n  update_player_slots(player)\n  \nend','function onbeginturn(player)\n  \n  log(\"BEGINTURN, \" .. player.name)\n  \n  -- Roll dice\n  player.slots[1] = {__type = \"dice\", value = 2}\n  player.slots[2] = {__type = \"dice\", value = 2}\n  roll_dice(player.slots[1])\n  roll_dice(player.slots[2])\n  \n  update_player_slots(player)\n    \n  -- Update available moves\n  if player.slots[1].value == player.slots[2].value then\n    -- Rolled double\n    local val = player.slots[1].value\n    player.moves = {val, val, val, val}\n    chat(player.name .. \" rolled double! Move 4 pieces.\")\n  else\n    player.moves = {player.slots[1].value, player.slots[2].value}\n    chat(player.name .. \" will move 2 pieces.\")\n  end\n  \n  if not can_move(player) then\n    player.can_move = false\n    chat(player.name .. \" can\'t make a valid move, ending turn\")\n    end_turn()\n    return\n  end\n\n  player.can_move = true\n\n  -- Droppable slots\n  local slot_list = {}\n  table.insert(slot_list, {slot_type = \"table_slot\", slot_nrs = draggable(player)\n      --[[{\n      1, 2, 3, 4, 5, 6, \n      8, 9, 10, 11, 12, 13,\n      14, 15, 16, 17, 18, 19,\n      21, 22, 23, 24, 25, 26\n    }--]]\n    }\n  )\n  \n  -- Check if player has a hit marker to enter\n  local prison = table_slots[player.prison]\n  if #prison > 1 then\n  	-- This is the only marks to move\n    local marks = {}\n    for i = 2, #prison do\n      table.insert(marks, prison[i])\n    end\n  	enable_draggable({player}, marks, slot_list, function(player, src, dest)\n        \n        log(\"drop from prison\")\n        \n        if my_turn(player) then\n          \n          for k, move in pairs(player.moves) do\n          \n            -- Find distance\n            local dist = 0\n            for k2, v in ipairs(player.road) do\n              if v == dest.slot_nr then\n                dist = k2\n              end\n            end\n            \n            log(\"dist = \" .. dist)\n            log(\"move = \" .. move)\n            \n            if dist == move then\n              \n              log(\"dist == move\")\n              \n              local opponent_title = player.player_nr == 1 and \"backg black\" or \"backg red\"\n              local opponent = player.player_nr == 1 and player2 or player1\n            \n              player.moves[k] = nil\n              \n              if (table_slots[dest.slot_nr][2] and\n                 table_slots[dest.slot_nr][2].title == opponent_title) then\n                chat(player.name .. \" grabbed a piece!\")\n                opponent.taken = true\n                local mark = table.remove(table_slots[dest.slot_nr], 2)\n                table.insert(table_slots[opponent.prison], mark)              \n                format_prison(opponent)\n                local mark = table.remove(table_slots[src.slot_nr], #table_slots[src.slot_nr])\n                table.insert(table_slots[dest.slot_nr], mark)\n                format_slot(table_slots[dest.slot_nr], dest.slot_nr)\n                format_prison(player)\n                break\n              else\n                local mark = table.remove(table_slots[src.slot_nr], #table_slots[src.slot_nr])\n                table.insert(table_slots[dest.slot_nr], mark)\n                -- Fix mark top px distance\n                format_slot(table_slots[dest.slot_nr], dest.slot_nr)\n                format_prison(player)\n                break\n              end\n\n            end\n            \n          end\n          \n        end\n        \n        update_table()\n        \n        -- If prison is empty, enable all marks\n        if #prison == 1 then\n          enable_all_draggable(player, slot_list)\n        end\n        \n        -- If all marks are in home, enable onclick\n        if not mark_outside_home(player) then\n          enable_bearoff(player)\n        else\n        \n        end\n        \n        -- Check if the player can move\n        if not can_move(player) then\n          chat(\"No legal moves left for \" .. player.name .. \", ending turn\")\n          end_turn()\n          return\n        end\n        \n      end\n    )\n    \n    update_table()\n    return\n\n  end\n\n  -- Check if all marks are in the players home\n  local mark_outside_home_ = mark_outside_home(player)\n  \n  --log(\"mark_outside_home = \" .. tostring(mark_outside_home_))\n\n  -- Enable all checkers to be draggable\n  enable_all_draggable(player, slot_list)\n\n  -- If all marks are in home, enable onclick to move mark out of board\n  if not mark_outside_home_ then\n    enable_bearoff(player)\n  end\n  \nend',2,0,0);
/*!40000 ALTER TABLE `ds_game` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-11-27 23:46:37
