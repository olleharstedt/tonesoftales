-- MySQL dump 10.13  Distrib 5.5.34, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: d37433
-- ------------------------------------------------------
-- Server version	5.5.34-0ubuntu0.12.10.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `ds_game`
--
-- WHERE:  id=35

LOCK TABLES `ds_game` WRITE;
/*!40000 ALTER TABLE `ds_game` DISABLE KEYS */;
INSERT INTO `ds_game` VALUES (35,'Texas hold\'em (no limit)','Classic poker game texas holdem, no limit.','\n\n--whitechips = {}\n\ngame_state = \"set_dealer\"\n\nsmall_blind = 0\nbig_blind = 0\n\n-- Minimum bet allowed\nmin_bet = 0\n\n-- The dealer\ndealer = nil\n\n-- Current raise. A re-raise must be higher than this\nraise = 0\n\n-- All in\nall_in = false\n\n-- Pre-init\nfor _, p in ipairs(players) do\n   p.money = 500\nend\n\nplayer1.money = 1000\n\nfunction init()\n  \n  if #players == 1 then\n    chat(\"Too few players\")\n    game_over()\n  end\n\n  set_values(deck1)\n  -- Set ace to 14\n  for _,c in ipairs(deck1.cards) do\n    if c.value == 1 then\n      c.value = 14\n    end\n  end\n  shuffle(deck1)\n  \n  -- Face down as default\n  for _, c in ipairs(deck1.cards) do\n    c.facing = \"down\"\n  end\n  \n  --[[\n  add_gadget {\n    gadget_id = 123,\n    type = \"confirm\",\n    players = players,\n    text = \"<script>alert(\'hej\');</script>\",\n    callback = function() end\n  }\n  --]]\n  \n  \n  table_slots[1] = deck1\n  table_slots[2] = {__type = \"stack\"} -- Trash\n  table_slots[3] = nil\n  table_slots[4] = nil\n  table_slots[5] = nil\n  table_slots[6] = nil\n  table_slots[7] = nil\n  \n  update_table()\n  \n  redchips = {}\n  bluechips = {}\n  greenchips = {}\n  blackchips = {}\n  \n  -- Init chips\n  -- Copy chips from deck2 to tables of 100 chips\n  for i = 1, 100 do\n    local c = shallowcopy(deck2.cards[8])\n    c.facing = \"up\"\n    c.position = {top = 0}\n    table.insert(redchips, c)\n  end\n  for i = 1, 100 do\n    local c = shallowcopy(deck2.cards[9])\n    c.facing = \"up\"\n    c.position = {top = 0}\n    table.insert(bluechips, c)\n  end\n  for i = 1, 100 do\n    local c = shallowcopy(deck2.cards[11])\n    c.facing = \"up\"\n    c.position = {top = 0}\n    table.insert(greenchips, c)\n  end \n  for i = 1, 100 do\n    local c = shallowcopy(deck2.cards[10])\n    c.facing = \"up\"\n    c.position = {top = 0}\n    table.insert(blackchips, c)\n  end\n  player1.chips = {__type = \"stack\"}\n\n  --[[\n  bluechips[1].position.top = 18\n  redchips[1].position.top = 12\n  greenchips[1].position.top = 6\n  blackchips[1].position.top = 0\n  table.insert(player1.chips, bluechips[1])\n  table.insert(player1.chips, redchips[1])\n  table.insert(player1.chips, greenchips[1])\n  table.insert(player1.chips, blackchips[1])\n  deck2.cards[13].facing = \"up\"\n  player1.slots[1] = player1.chips\n  player1.slots[2] = deck2.cards[13]  \n  update_player_slots(player1)\n  --]]\n  \n  -- Init player gadgets\n  for k, p in ipairs(players) do\n    -- Slider\n    p.slider = {\n      gadget_id = k,\n      players = {p},\n      type = \"slider\",\n      range = {0, 500},\n      step = 5,\n      callback = function(player, value)\n        p.slider_value = value\n      end\n    }\n    p.slider_value = 0\n    \n    -- Call button, also used for check\n    -- Calls min bet\n    p.call_button = {\n      gadget_id = 200 + k,\n      players = {p},\n      type = \"button\",\n      text = \"Call\",\n      -- Calling/checking does not change min_bet\n      callback = function(p)\n        local min = min_bet - p.bet > 0 and min_bet - p.bet or 0\n        if my_turn(p) and all_in and game_state ~= \"showdown\" and p.money > 0 then\n          p.bet = p.bet + p.money\n          p.money = 0\n          \n          update_points()\n          set_chips(p)\n          p.active = true\n          p.all_in = true\n          \n          check_game_state(p)\n          \n        elseif my_turn(p) and p.money >= min and game_state ~= \"showdown\" then\n          log(p.name .. \" call \" .. min)\n          p.money = p.money - min\n          p.bet = p.bet + min\n          update_points()\n          set_chips(p)\n          p.active = true\n\n          check_game_state(p)\n          \n        end\n      end\n    }\n    \n    -- Raise button, also bet\n    -- Raise/bet > min bet\n    p.raise_button = {\n      gadget_id = 300 + k,\n      players = {p},\n      type = \"button\",\n      text = \"Raise\",\n      callback = function(p)\n        local min = min_bet - p.bet > 0 and min_bet - p.bet or 0\n        if players_turn.player_nr == p.player_nr \n           and p.slider_value > min \n           and p.slider_value <= p.money \n           and not all_in \n           and game_state ~= \"showdown\" then\n		  \n		  -- Abort if raise is too small   \n          -- TODO: Do this or not?\n          --if p.slider_value < raise * 2 then\n          --  chat(\"Raise must be higher than current raise, \" .. raise)\n          --  return\n          --end\n          \n          log(p.name .. \" raise with \" .. p.slider_value)\n          p.money = p.money - p.slider_value\n          p.bet = p.bet + p.slider_value\n          min_bet = p.bet\n          raise = p.slider_value \n          log(\"min_bet = \" .. min_bet)\n          log(\"raise = \" .. raise)\n          update_points()\n          set_chips(p)\n          p.active = true\n        \n          check_game_state(p)\n          \n        end\n      end\n    }\n    \n    p.all_in_button = {\n      gadget_id = 500 + k,\n      players = {p},\n      type = \"button\",\n      text = \"All-in\",\n      callback = function(p)\n        if my_turn(p) and all_in == false and game_state ~= \"showdown\" then\n          \n          all_in = true\n          \n          p.bet = p.bet + p.money\n          p.money = 0\n          p.active = true\n          p.all_in = true\n          \n          update_points()\n          set_chips(p)\n          \n          check_game_state(p)\n          \n        end\n      end\n    }\n    \n    p.fold_button = {\n      gadget_id = 400 + k,\n      players = {p},\n      type = \"button\",\n      text = \"Fold\",\n      callback = function(p)\n        if my_turn(p) and game_state ~= \"showdown\" then\n        \n          p.is_fold = true\n          \n          -- Move cards to trash (table_slot 2)\n          move_card(p.hand[1], {slot_type = \"table_slot\", slot_nr = 2})\n          move_card(p.hand[2], {slot_type = \"table_slot\", slot_nr = 2})\n          sleep(500)\n          \n          local c = table.remove(p.hand, 1)\n          table.insert(table_slots[2], c)\n          c = table.remove(p.hand, 1)\n          table.insert(table_slots[2], c)\n          update_hand(p)\n          update_table(p)\n          \n          -- Check if all has fold except one\n          local nr_fold = 0\n          local winning_player = nil\n          players:iter(function(p) \n              if p.is_fold then \n                nr_fold = nr_fold + 1 \n              else\n                winning_player = p\n              end\n            end\n          )\n          if #players - nr_fold == 1 and winning_player then\n            -- We have a winner!\n            local sum = 0\n            for _, p in ipairs(players) do\n              sum = sum + p.bet\n            end\n            chat(winning_player.name .. \" won \" .. sum)\n            winning_player.money = winning_player.money + sum\n            \n            cleanup()\n            \n            -- Set all bets to 0\n            players:iter(function(p) p.bet = 0; set_chips(p) end)\n            update_points()\n            \n            game_state = \"set_dealer\"\n            \n            -- Init and start again\n            init()\n            \n            -- Set turn to player next to dealer (who will become the next dealer)\n            --log(\"dealer nr \" .. dealer.player_nr)\n            --next_player = dealer.player_nr + 1\n            --if next_player > #players then next_player = 1 end\n            --dealer = players[next_player]\n            --log(\"set turn to \" .. next_player)\n            -- set_turn(dealer.player_nr)\n            -- end_turn will happen here, setting turn to player after dealer\n          else\n            -- No winner, check if we should go to next round\n            check_game_state()\n            \n          end\n        end\n      end\n    }\n    \n    p.slots[2] = nil  -- No dealer button\n    p.is_fold = false\n   \n    p.bet = 0\n    p.active = false -- True if player has called, checked or raised this betting round\n    p.all_in = false -- True if player has bet all money in bank\n    \n    p.points = 0\n    p.high = 0\n  end\n \n \n  -- Give 50 bucks to broke players\n  players:iter(function (p) if p.money <= 10 then p.money = p.money + 50 end end)\n  \n  -- Set dealer\n  if dealer == nil then\n    players_turn.is_dealer = true\n    dealer = players_turn\n    log(\"dealer = \" .. dealer.name)\n    end_turn()\n  else\n    next_dealer = dealer.player_nr + 1\n    if next_dealer > #players then next_dealer = 1 end\n    dealer = players[next_dealer]\n    log(\"dealer = \" .. dealer.name)\n    -- set_turn(dealer.player_nr)\n  end\n  \n  -- Reset raise to big blind\n  raise = 10\n  \n  all_in = false\n  \n  -- Dealer button\n  deck2.cards[13].facing = \"up\"\n  dealer.slots[2] = deck2.cards[13]\n  dealer.slots[1] = {__type = \"stack\"}  -- TODO: Hack, should not be needed\n  update_player_slots(dealer)\n  \n  game_state = \"small_blind\"\n  \n  -- Set turn to dealer, then end it\n  set_turn(dealer.player_nr)\n  end_turn()\n  \nend\n\n-- Add the four gadgets for all players\nfunction add_gadgets()\n  players:iter(function(p)\n    if not gadget_exists(p.slider) then\n      add_gadget(p.slider)\n      add_gadget(p.fold_button)\n      add_gadget(p.call_button)\n      add_gadget(p.raise_button)\n      add_gadget(p.all_in_button)\n    end\n  end)\nend\n\n-- Check if we\'re ready to change game state\n-- Which we are if all checked or all bets are equal\nfunction check_game_state(player)\n  \n  log(\"check game state\" .. game_state)\n  \n  if game_state == \"pre_flop\" then\n    if next_round() then\n      -- Flop three cards\n      move_card(table_slots[1].cards[1], {slot_type = \"table_slot\", slot_nr = 3})\n      sleep(200)\n      move_card(table_slots[1].cards[1], {slot_type = \"table_slot\", slot_nr = 4})\n      sleep(200)\n      move_card(table_slots[1].cards[1], {slot_type = \"table_slot\", slot_nr = 5})\n      sleep(500)\n      local c = draw_card()\n	  c.facing = \"up\"\n      table_slots[3] = c \n      c = draw_card()\n	  c.facing = \"up\"\n      table_slots[4] = c \n      c = draw_card()\n	  c.facing = \"up\"\n      table_slots[5] = c \n	  update_table()\n      \n      game_state = \"flop1\"\n      \n      min_bet = 0\n      raise = 0\n      \n      -- Change \'Call\' to \'Check\' and \'Raise\' to \'Bet\'\n      for _, p in ipairs(players) do\n        p.call_button.text = \"Check\"\n        update_gadget(p.call_button)\n        p.raise_button.text = \"Bet\"\n        update_gadget(p.raise_button)\n      end\n      \n      -- Set non-active\n      players:iter(function(p) p.active = false end)\n      \n      -- Go to player after dealer\n      set_turn(dealer.player_nr)\n      \n    end\n  elseif game_state == \"flop1\" then\n    -- Check if all bets are equal and everyone\'s done something - if so, flop one card\n    if next_round() then\n      \n      game_state = \"flop2\"\n      \n      min_bet = 0\n      raise = 0\n      \n      -- Change \'Call\' to \'Check\' and \'Raise\' to \'Bet\'\n      for _, p in ipairs(players) do\n        p.call_button.text = \"Check\"\n        update_gadget(p.call_button)\n        p.raise_button.text = \"Bet\"\n        update_gadget(p.raise_button)\n      end\n      \n      -- Flop the forth card\n      move_card(table_slots[1].cards[1], {slot_type = \"table_slot\", slot_nr = 6})\n      sleep(500)\n      local c = draw_card()\n	  c.facing = \"up\"\n      table_slots[6] = c \n      update_table()\n      \n      -- Set non-active\n      players:iter(function(p) p.active = false end)\n      \n      -- Go to player after dealer\n      set_turn(dealer.player_nr)\n      \n    end\n  elseif game_state == \"flop2\" then\n    -- Check for equal bets or all checks\n    if next_round() then\n      \n      game_state = \"flop3\"\n      \n      min_bet = 0\n      raise = 0\n      \n      -- Change \'Call\' to \'Check\' and \'Raise\' to \'Bet\'\n      for _, p in ipairs(players) do\n        p.call_button.text = \"Check\"\n        update_gadget(p.call_button)\n        p.raise_button.text = \"Bet\"\n        update_gadget(p.raise_button)\n      end\n      \n      -- Flop the fifth card\n      move_card(table_slots[1].cards[1], {slot_type = \"table_slot\", slot_nr = 7})\n      sleep(500)\n      local c = draw_card()\n	  c.facing = \"up\"\n      table_slots[7] = c \n      update_table()\n      \n      -- Set non-active\n      players:iter(function(p) p.active = false end)\n      \n      -- Go to player after dealer\n      set_turn(dealer.player_nr)\n    end\n  elseif game_state == \"flop3\" then\n    -- Check for equal bets or all checks\n    if next_round() then\n    \n      game_state = \"showdown\"\n\n      -- Calculate pot\n      local sum = 0\n      for _, p in ipairs(players) do\n        sum = sum + p.bet\n      end\n      \n      -- Array of winners\n      local winners = {{points = 0}}\n      \n      local win_message = function(p)\n        chat(p.name .. \" won \" .. sum .. \"$ with \" .. points_to_string(p.points, p.kickers))\n        --if kicker then\n        --  chat(\"Kicker was \" .. card_to_string(kicker))\n        --end\n      end\n\n	  -- Check who won and distribute the pot to them      \n      local distribute_pot = function()\n        \n        local winners = {{points = 0}}\n        \n        for _, p in ipairs(players) do\n          if not p.is_fold then \n            p.points, p.kickers = calc_points(p)\n            --p.points = p.points + p.high\n            if p.points > winners[1].points then\n              winners = {p}\n            elseif p.points == winners[1].points then\n              table.insert(winners, p)\n            end  \n          else\n            p.points = 0\n            p.high = 0\n          end\n        end\n        \n        if #winners == 1 then\n          win_message(winners[1])\n        \n          -- Move money to winner\n          winners[1].money = winners[1].money + sum\n          \n        else\n          \n          -- No winner won by points, so two or more players have the same deal; compare kickers\n          \n          -- Check so all comparing players have equal amount of kickers\n          local n = #winners[1].kickers\n          for _, p in ipairs(winners) do\n            if #p.kickers ~= n then\n              chat(\"Error: Not equal amount of kickers for points = \" .. winners[1].points)\n              return\n            end\n          end\n\n          local winners2 = {}\n          \n          -- Loop kickers\n          for i = 1, #winners[1].kickers do \n            winners2 = {}\n            for _, p in ipairs(winners) do\n              \n              local v = winners2[1] and winners2[1].kickers[i] or 0\n              \n              if p.kickers[i] > v then\n                winners2 = {p}\n              elseif p.kickers[i] == v then\n                table.insert(winners2, p)\n              end\n              \n            end\n            \n            if #winners2 == 1 then\n              local winner = winners2[1]\n              win_message(winner) -- , winner.kickers[i])\n              winner.money = winner.money + sum\n              return\n            end\n            \n          end\n          \n          -- If we ended up here, we must split\n          \n          -- Split\n          local share = math.floor(sum / #winners2)\n          chat(\"Splitting, each share is \" .. share .. \"$\")\n          for _, p in ipairs(winners2) do\n            p.money = p.money + share\n          end\n          \n        end\n      end\n      \n      distribute_pot()\n            \n      -- Move cards in hand to player slots\n      -- OBS: Must do this after distribute_pot, because that get matches from hand\n      players:iter(function(p)\n          if (p.hand[1] and p.hand[2]) then  -- Will have no hand if folded earlier\n            p.slots[2] = {__type = \"overlay\"}\n            p.hand[1].facing = \"up\"\n            p.hand[2].facing = \"up\"\n            table.insert(p.slots[2], p.hand[1])\n            table.insert(p.slots[2], p.hand[2])\n            p.hand = {}\n            update_player_slots(p)\n            update_hand(p)\n          end\n        end\n      )\n      \n      chat(\"Press Deal\")\n      \n      update_points()\n      \n      g_next_round = {\n        gadget_id = 999,\n        text = \"Deal\",\n        players = players,\n        type = \"button\",\n        callback = function()\n          remove_gadget(g_next_round)\n                \n          cleanup()\n          \n          game_state = \"set_dealer\"\n          \n          init()\n        end\n      }\n      \n      add_gadget(g_next_round)\n\n      return\n      \n    end\n  end\n  \n  end_turn()\n  \nend\n\n-- Recirsive function to get winners from @ps\n--[[\nfunction get_winners(ps)\n\n  winners = {{points = 0, high = 0}}\n  \n  for _, p in ipairs(ps) do\n    if p.points > winners[1].points then\n      winners = {p}\n    elseif p.points == winners[1].points then\n      table.insert(winners, p)\n    end\n  end\n  \n  if #winners < #ps and #winners > 1 then\n    return get_winners(winners)\n  end\n  \n  return winners\n\nend\n--]]\n\n-- Return string of points, e.g. 500, 13 -> \"flush,  king high\"\nfunction points_to_string(points, kickers)\n \n  local card = card_to_string(kickers[1])\n  local low = card_to_string(kickers[2])\n  \n  if points == 900 then\n    return \"royal straight!\"\n  elseif points == 800 then\n    return \"straight flush, \" .. card .. \" high\"\n  elseif points == 700 then\n    return \"four of a kind, \" .. card .. \" high\"\n  elseif points == 600 then\n    return \"full house, \" .. card .. \" and \" .. low\n  elseif points == 500 then\n    return \"flush, \" .. card .. \" high\"\n  elseif points == 400 then\n    return \"straight, \" .. card .. \" high\"\n  elseif points == 300 then\n    return \"three of a kind, \" .. card .. \" high\"\n  elseif points == 200 then\n    return \"two pairs, \" .. card .. \" and \" .. low\n  elseif points == 100 then\n    return \"pair, \" .. card .. \" high\"\n  else\n    return \"high card, \" .. card_to_string(points)\n  end\n  \nend\n  \n-- Return string of value\nfunction card_to_string(value)\n  if value == 14 then return \"ace\"\n  elseif value == 13 then return \"king\"\n  elseif value == 12 then return \"queen\"\n  elseif value == 11 then return \"jack\"\n  else return tostring(value) end\nend\n\n-- Return all cards to deck\nfunction cleanup()\n  \n  -- Some animation\n  log(\"cleanup\")\n  \n  local dest = {slot_type = \"table_slot\", slot_nr = 1}\n  \n  --[[\n  if #table_slots[2] > 0 then\n    for _, c in ipairs(table_slots[2]) do\n      move_card(table_slots[2][1], dest)\n    end\n  end\n  --]]\n    \n  if table_slots[3] then move_card(table_slots[3], dest) end\n  if table_slots[4] then move_card(table_slots[4], dest) end\n  if table_slots[5] then move_card(table_slots[5], dest) end\n  if table_slots[6] then move_card(table_slots[6], dest) end\n  if table_slots[7] then move_card(table_slots[7], dest) end\n  \n  players:iter(\n    function(p)\n      if p.is_fold == false then\n        log(\"moving cards for \" .. p.name)\n        if p.hand[1] then move_card(p.hand[1], dest) end\n        if p.hand[2] then move_card(p.hand[2], dest) end\n        if p.slots[2] and p.slots[2].__type == \"overlay\" then\n          move_card(p.slots[2][1], dest)\n          move_card(p.slots[2][2], dest)\n        end\n      end\n    end\n  )\n\n  sleep(500)\n  \n  -- Move trash to deck\n  for i = 1, #table_slots[2] do\n    local c = table.remove(table_slots[2], 1)\n    c.facing = \"down\"\n    table.insert(deck1.cards, c)\n  end\n  \n  -- Move flop to deck\n  for i = 3, 7 do\n    if table_slots[i] then\n      table.insert(deck1.cards, table_slots[i])\n      table_slots[i] = nil\n    end\n  end\n  \n  -- Move player hand to deck1\n  players:iter(\n    function(p)\n      if p.is_fold == false then\n        if p.hand[1] then table.insert(deck1.cards, p.hand[1]); p.hand[1] = nil end\n        if p.hand[2] then table.insert(deck1.cards, p.hand[2]); p.hand[2] = nil end\n        if p.slots[2] and p.slots[2].__type == \"overlay\" then\n          table.insert(deck1.cards, p.slots[2][1])\n          table.insert(deck1.cards, p.slots[2][2])\n          p.slots[2] = nil\n        end\n      end\n  	update_hand(p)\n    end\n  )\n  \n  assert(#deck1.cards == 52, \"cleanup: deck not 52, but \" .. #deck1.cards)\n  --log(\"#deck1 = \" .. #deck1.cards)\n  \n  update_table(p)\n  --]]\nend\n\n\n-- Update the points table with bank, bet\nfunction update_points()\n  \n  local points_table = {}\n\n  local names = {\"\"}  \n  players:iter(function(p) table.insert(names, p.name) end) \n  table.insert(points_table, names)\n  \n  local money = {\"Bank\"}\n  players:iter(function(p) table.insert(money, p.money) end)\n  table.insert(points_table, money)\n  \n  local bet = {\"Bet\"}\n  players:iter(function(p) table.insert(bet, tonumber(p.bet) or 0) end)\n  table.insert(points_table, bet)\n  \n  update_points_table(points_table)\n  \nend\n\n-- Deal two cards to each player\nfunction deal_cards()\n\n  for _, p in ipairs(players) do\n    move_card(table_slots[1].cards[1], {slot_type = \"player_hand\", player = p})\n    sleep(200)\n    move_card(table_slots[1].cards[1], {slot_type = \"player_hand\", player = p})\n    sleep(500)\n  end\n\n  players:iter(function(p)\n    table.insert(p.hand, draw_card())\n    table.insert(p.hand, draw_card())\n    update_hand(p)\n  end)\n  \n  game_state = \"pre_flop\"\n  \nend\n\nfunction draw_card()\n  return table.remove(deck1.cards, 1)\nend\n  \n-- True if it\'s @p turn\nfunction my_turn(p)\n  return players_turn.player_nr == p.player_nr\nend\n\n-- True if all non-folded players have equal bet\nfunction next_round()\n  local next_round = true\n  \n  -- Find first non-fold bet to compare others with\n  for _, p in ipairs(players) do\n    if not p.is_fold then\n      compare = p.bet\n      break\n    end\n  end\n  \n  -- Check for equal bets (only if no all-in has been made)\n  if not all_in then\n    for _, p in ipairs(players) do\n      if not p.is_fold and p.bet ~= compare then\n        next_round = false\n      end\n    end\n  -- If all-in, check so all players has bet every penny (if not fold)\n  else\n    for _, p in ipairs(players) do\n      if not p.is_fold and p.money > 0 then\n        next_round = false\n      end\n    end\n  end\n  \n  -- Check for inactivity\n  for _, p in ipairs(players) do\n    if not p.is_fold and not p.active then\n      next_round = false\n    end\n  end\n    \n  return next_round\nend\n\n-- Set chips for player @p from his/hers bet\nfunction set_chips(p)\n\n  -- Remove current chips\n  p.slots[1] = {__type = \"stack\"}\n  \n  local reds, blues, greens, blacks = 0, 0, 0, 0\n  local bet = p.bet\n  \n  blacks = math.floor(bet / 100)\n  bet = bet - (blacks * 100)\n  \n  greens = math.floor(bet / 25)\n  bet = bet - (greens * 25)\n  \n  blues = math.floor(bet / 10)\n  bet = bet - (blues * 10)\n  \n  reds = math.floor(bet / 5)\n  bet = bet - (reds * 5)\n  \n  -- TODO: Add support for white chips (value 1)\n  \n  assert(bet == 0, \"Bet should be 0 here\")\n  \n  local n = blacks + greens + blues + reds\n\n  log(blacks)\n  log(greens)\n  log(blues)\n  log(reds)\n  \n  -- Get chips from chips bank\n  for i = 1, n do\n\n    if reds > 0 then\n      local c = table.remove(redchips, 1)\n      c.position.top = i * 7\n      table.insert(p.slots[1], 1, c)\n      reds = reds - 1\n    elseif blues > 0 then\n      local c = table.remove(bluechips, 1)\n      c.position.top = i * 7\n      table.insert(p.slots[1], 1, c)\n      blues = blues - 1\n    elseif greens > 0 then\n      local c = table.remove(greenchips, 1)\n      c.position.top = i * 7\n      table.insert(p.slots[1], 1, c)\n      greens = greens - 1\n    elseif blacks > 0 then      \n      local c = table.remove(blackchips, 1)\n      c.position.top = i * 7\n      table.insert(p.slots[1], 1, c)\n      blacks = blacks - 1\n    end\n    \n  \n  end\n\n  update_player_slots(p)\n  \nend\n\n-- True if no player has been active this round\nfunction none_active()\n  return players:every(function(p) return p.active == false end)\nend\n\n-- Sort cards in hand after value\nfunction sort_hand(player)\n  table.sort(player.hand, function(x, y) return x.value > y.value end)\nend\n\n-- Return list of all matches\n-- Assumes ace has value 14\nfunction get_matches(player)\n  \n  --log(\"get_matches\")\n  \n  local matches = {}\n  \n  for i=2,14 do matches[i] = 0 end\n  \n  -- Get matches from hand (two cards)\n  for index, card in ipairs(player.hand) do\n    matches[card.value] = matches[card.value] + 1\n  end\n  \n  -- Get matches from flop (3-5 cards)\n  for i = 3, 7 do \n    local c = table_slots[i]\n    if c and c.__type == \"card\" then\n      --log(dump(c))\n      matches[c.value] = matches[c.value] + 1\n    end\n  end\n  \n  return matches\nend\n\n-- Return matches table with sum of cards in each suit\nfunction get_suits(player)\n\n  local card_values = {}\n  local matches = {\n    spades = 0,\n    clubs = 0,\n    hearts = 0,\n    diamonds = 0\n  }\n  \n  -- Suits in hand\n  for _, c in ipairs(player.hand) do\n    matches[c.suit] = matches[c.suit] + 1\n    table.insert(card_values, c.value)\n  end\n  \n  -- Suits in flop\n  for i = 3, 7 do\n    local c = table_slots[i]\n    if (c and c.__type == \"card\") then\n      matches[c.suit] = matches[c.suit] + 1\n      table.insert(card_values, c.value)\n    end\n  end\n  \n  table.sort(card_values, function(x, y) return x > y end)\n  \n  return matches, card_values\n\nend\n\n-- Return next highest value for matches @ms\nfunction get_next_highest(ms)\n  local result = 0\n  for i = 14, 2, -1 do\n    if ms[i] > 0 then\n      ms[i] = ms[i] - 1\n      return i\n    end\n  end  \nend\n\n-- Choose the highest five cards\n-- Return points (first highest card) and kickers (4 highest cards after)\nfunction high_card(p)\n  \n  local ms = get_matches(p)\n  local points, kickers = 0, {}\n  \n  -- Find first\n  points = get_next_highest(ms)\n  \n  -- Get kickers (two more)\n  for j = 1, 4 do\n    table.insert(kickers, get_next_highest(ms))\n  end\n\n  return points, kickers\n  \nend\n\n-- Return true if player has a straight\nfunction has_straight(p)\n  local hand = p.hand\n  \n  local ms = get_matches(p)\n  \n  for i = 10, 2, -1 do\n    if (ms[i] > 0 and\n        ms[i + 1] > 0 and\n        ms[i + 2] > 0 and\n        ms[i + 3] > 0 and\n        ms[i + 4] > 0) then\n      return i + 4 -- Return highest card in straight\n    end\n  end\n\n  -- Check for straight beginning with ace, 2, 3, 4, 5\n  if (ms[2] > 0 and\n      ms[3] > 0 and\n      ms[4] > 0 and\n      ms[5] > 0 and\n      ms[14] > 0) then\n    return 5\n  end\n  \n  return false\n  \nend\n\n-- Return true if all cards are in the same suit\n-- Assumes hand.length == 5\nfunction has_flush(p)\n  \n  local ms = get_suits(p)\n  \n  for _, v in ipairs(ms) do\n    if v > 4 then return true end\n  end\n  \n  return false\n  \nend\n\n\n-- Assumes hand is sorted with highest at index 1\n-- Return points, high, low and kickers\nfunction get_royal(p)\n\n  if has_flush(p) and has_straight(p) == 14 then\n    return 900, {14}\n  end\n  \n  return false\n\nend\n\nfunction get_straightflush(p)\n  \n  local r = has_straight(p)\n  \n  if has_flush(p) and r then\n    return 800, {r}\n  end\n  \n  return false\n  \nend\n\nfunction get_fourkind(p)\n  local ms = get_matches(p)\n  \n  for i = 14, 2, - 1 do\n    if ms[i] == 4 then\n      ms[i] = ms[i] - 4\n      \n      local low = get_next_highest(ms)\n      \n      return 700, {i, low}\n    end\n  end\n  \n  return false\n  \nend\n\nfunction get_fullhouse(p)\n\n  local matches = get_matches(p)\n  local low, high = false, false\n  \n  for i = 2, 14 do\n  	if matches[i] == 3 then high = i end\n    if matches[i] == 2 then low = i end\n  end\n  \n  if high == false or low == false then\n    return false\n  else\n    return 600, {high, low}\n  end\nend\n\nfunction get_flush(p)\n  \n  -- Find highest card\n  local ms = get_matches(p)\n  local kickers = {}\n  \n  if has_flush(p) then\n    \n    for i = 1, 5 do\n      table.insert(kickers, get_next_highest(ms))\n    end\n    \n    return 500, kickers\n  end\n   \n  return false\n  \nend\n\n-- Return 400, top card value\nfunction get_straight(p)\n  \n  local r = has_straight(p)\n  \n  if r then return 400, {r} end\n  \n  return false\n  \nend\n\nfunction get_threekind(p)\n  local ms = get_matches(p)\n  \n  for i=14, 2, -1 do\n    if ms[i] == 3 then -- No ms[i] should > 3 here\n      \n      ms[i] = 0\n\n      return 300, {i, get_next_highest(ms), get_next_highest(ms)}\n    end\n      \n  end\n  \n  return false\nend\n\n-- Return points for a two pair, or false if not found\nfunction get_twopair(player)\n\n  local matches = get_matches(player)\n  local pars = 0\n  local high = 0\n  \n  for i = 14, 2, -1 do\n    --chat(\"matches[i] = \" .. matches[i])\n    if matches[i] == 2 then\n      matches[i] = matches[i] - 2\n      pars = pars + 1\n      if high == 0 then high = i else low = i end\n    end\n  end\n  \n  if pars == 2 then \n    return 200, {high, low, get_next_highest(matches)} -- Kickers\n  else\n    return false\n  end\n  \nend\n\n-- Return points of a pair, or false if no pair is found\nfunction get_pair(player)\n  \n  log(\"get_pair\")\n  \n  local matches = get_matches(player)\n  \n  for i = 14, 2, -1 do\n    --chat(\"matches[i] = \" .. matches[i])\n    if matches[i] == 2 then\n      \n      matches[i] = matches[i] - 2\n      \n      local kickers = {}\n      \n      table.insert(kickers, i)\n      \n      for j = 1, 3 do\n        table.insert(kickers, get_next_highest(matches))\n      end\n      \n      return 100, kickers\n    end\n  end\n  \n  return false\nend\n\n-- Return total points for player\nfunction calc_points(player)\n\n  log(\"calc_points \" .. player.name)\n  \n  log(\"mathes = \" .. dump(get_matches(player)))\n  \n  local points, high, low, kickers = 0, 0, 0, {}\n  local funcs = {}\n  \n  funcs[1] = get_royal\n  funcs[2] = get_straightflush\n  funcs[3] = get_fourkind\n  funcs[4] = get_fullhouse\n  funcs[5] = get_flush\n  funcs[6] = get_straight\n  funcs[7] = get_threekind\n  funcs[8] = get_twopair\n  funcs[9] = get_pair\n  funcs[10] = high_card\n  \n  for i, fn in ipairs(funcs) do\n\n    points, kickers = fn(player)\n    \n    log(tostring(i) .. \": points = \" .. tostring(points))\n    \n    -- Break when fn returns with any points\n    if points ~= false then\n      break\n    end\n    \n  end\n  \n  --[[local function calc_aux(i)\n    chat(\"i = \" .. i)\n  	local points = funcs[i](player)\n    if points == false then\n      return calc_aux(i + 1)\n    else\n      return points + get_points(player)\n    end\n  end\n  --]]\n  \n  assert(points ~= false and points > 0)\n\n  log(\"kickers = \" .. dump(kickers))\n  \n  return points, kickers\n  \nend\n\n\n\n\n-- Add a `foreach` function to a table\nfunction array(t)\n  \n  mt = {\n    iter = function(self, fn) \n  	  for _, o in ipairs(self) do\n        fn(o) \n      end\n    end,\n    every = function(self, fn)\n      for _, o in ipairs(self) do\n        if fn(o) == false then\n          return false\n        end\n      end\n      return true\n    end\n  }\n  setmetatable(t, {__index = mt})\nend\n\narray(players)\n\n-- A shallow copy function for tables\nfunction shallowcopy(orig)\n  local orig_type = type(orig)\n  local copy\n  if orig_type == \'table\' then\n    copy = {}\n    for orig_key, orig_value in pairs(orig) do\n      copy[orig_key] = orig_value\n    end\n  else -- number, string, boolean, etc\n    copy = orig\n  end\n  return copy\nend',22,1,5,1,1,2,7,1,'function onpickup_all(player, deck)\nend','function onplay_all(player, card)\nend','\n-- Run after end_turn for the relevant player\nfunction onendturn(player)\n  \n  log(\"onendturn \" .. player.name .. \" \" .. game_state)\n  \n  log(debug.traceback())\n  \n  \nend','-- Run before each turn for relevant player\nfunction onbeginturn(player)\n   \n  log(\"onbeginturn \" .. player.name .. \" \" .. game_state)\n  \n  -- If play has fold, just move on\n  if player.is_fold then\n    end_turn()\n    return\n  end\n  \n  -- If player has all-in, move on\n  --[[if all_in and player.money == 0 and player.all_in then\n    if game_state == \"flop1\" or\n       game_state == \"flop2\" or\n       game_state == \"flop3\" then\n      end_turn()\n    end\n  end--]]\n  \n  -- If player is dealer and first this round, skip\n  if dealer and dealer.player_nr == player.player_nr and\n     players:every(function(p) return p.active == false end) then\n    log(\"skipping dealer\")\n    end_turn()\n    return\n  end\n  \n  -- Change \'Call\' to \'Check\' and \'Raise\' to \'Bet\'\n  --[[if min_bet == 0 then\n    for _, p in ipairs(players) do\n      p.call_button.text = \"Check\"\n      update_gadget(p.call_button)\n      p.raise_button.text = \"Bet\"\n      update_gadget(p.raise_button)\n    end\n  else\n    for _, p in ipairs(players) do\n      p.call_button.text = \"Call\"\n      update_gadget(p.call_button)\n      p.raise_button.text = \"Raise\"\n      update_gadget(p.raise_button)\n    end\n  end--]]\n  \n  if min_bet > 0 then\n    if gadget_exists(player.call_button) then\n      player.call_button.text = \"Call\"\n      update_gadget(player.call_button)\n    end\n    if gadget_exists(player.raise_button) then\n      player.raise_button.text = \"Raise\"\n      update_gadget(player.raise_button)\n    end\n  end\n  \n  -- Update slider to correct range\n  if gadget_exists(player.slider) and player.money >= (min_bet - player.bet) then\n    local min = min_bet - player.bet > 0 and min_bet - player.bet or 0\n    player.slider.range = {min, player.money}\n    log(player.name .. \" slider updated to min \" .. min)\n    update_gadget(player.slider)\n  end\n  \n\n  if game_state == \"small_blind\" then\n    local p = players_turn\n    p.money = p.money - 5\n    p.bet = 5\n    p.active = true\n    min_bet = 5\n    update_points()\n    set_chips(p)\n    game_state = \"big_blind\"\n    end_turn()\n  elseif game_state == \"big_blind\" then\n    local p = players_turn\n    p.money = p.money - 10\n    p.bet = p.bet + 10\n    p.active = true\n    min_bet = 10\n    update_points()\n    set_chips(p)\n    \n    show_hand_icon()\n    \n    deal_cards()\n    \n    game_state = \"pre_flop\"\n    add_gadgets()\n    end_turn()\n  end\n  \n  log(\"onbeginturn, end\")\nend ',5,1,1);
/*!40000 ALTER TABLE `ds_game` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-11-04 20:04:15
